/*
 * The FML Forge Mod Loader suite.
 * Copyright (C) 2012 cpw
 *
 * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

package cpw.mods.fml.common;

import com.google.common.base.Throwables;
import com.google.common.collect.Maps;
import com.google.gson.*;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import cpw.mods.fml.common.versioning.VersionParser;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Locale;
import java.util.Map;
import java.util.logging.Level;

public class MetadataCollection {
    private String modListVersion;
    private ModMetadata[] modList;
    private Map<String, ModMetadata> metadatas = Maps.newHashMap();
    private int metadataVersion = 1;

    public static MetadataCollection from(InputStream inputStream, String sourceName) {
        if (inputStream == null) {
            return new MetadataCollection();
        }

        InputStreamReader reader = new InputStreamReader(inputStream);
        try {
            MetadataCollection collection;
            Gson gson = new GsonBuilder()
                    .registerTypeAdapter(ArtifactVersion.class, new ArtifactVersionAdapter())
                    .setFieldNamingStrategy(f -> f.getName().toLowerCase(Locale.ROOT))
                    .create();
            JsonParser parser = new JsonParser();
            JsonElement rootElement = parser.parse(reader);
            if (rootElement.isJsonArray()) {
                collection = new MetadataCollection();
                JsonArray jsonList = rootElement.getAsJsonArray();
                collection.modList = new ModMetadata[jsonList.size()];
                int i = 0;
                for (JsonElement mod : jsonList) {
                    collection.modList[i++] = gson.fromJson(mod, ModMetadata.class);
                }
            } else {
                collection = gson.fromJson(rootElement, MetadataCollection.class);
            }
            collection.parseModMetadataList();
            return collection;
        } catch (JsonParseException e) {
            FMLLog.log(Level.SEVERE, e, "The mcmod.info file in %s cannot be parsed as valid JSON. It will be ignored", sourceName);
            return new MetadataCollection();
        } catch (Exception e) {
            throw Throwables.propagate(e);
        }
    }

    public ModMetadata getMetadataForId(String modId, Map<String, Object> extraData) {
        if (!metadatas.containsKey(modId)) {
            ModMetadata dummy = new ModMetadata();
            dummy.modId = modId;
            dummy.name = (String) extraData.get("name");
            dummy.version = (String) extraData.get("version");
            dummy.autogenerated = true;
            metadatas.put(modId, dummy);
        }
        return metadatas.get(modId);
    }

    private void parseModMetadataList() {
        for (ModMetadata modMetadata : modList) {
            metadatas.put(modMetadata.modId, modMetadata);
        }
    }

    public static class ArtifactVersionAdapter extends TypeAdapter<ArtifactVersion> {

        @Override
        public ArtifactVersion read(JsonReader in) throws IOException {
            return VersionParser.parseVersionReference(in.nextString());
        }

        @Override
        public void write(JsonWriter out, ArtifactVersion value) {
            // no op - we never write these out
        }
    }
}
